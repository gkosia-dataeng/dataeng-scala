https://www.youtube.com/playlist?list=PLS1QulWo1RIagob5D6kMIAvu7DQC5VTh3

SBT:
    Build tool: Compile, run, test, package a project
    Compile scala code
    Use Apache Ivy for dependency managment
    REPL: evaluate small code to test and debug parts of code

Use the REPL:
    To start the scala interpriter execute sbt console
    Scala is a compiled language so the REPL will generate a class file that will be compiled
    All intermitiate temp files of REPL will be generated to current folder
    It will 

Data types:

    Scala other data types:
        Unit:    void
        Null:    empty
        Nothing: nothing
        Any:     any 
        AnyRef:  any reference

Variables:

    var a : <data type> = <val> ==> with var the variable is muttable
    val a : <data type> = <val> ==> with val the variable is immutable
                                    error: reassignment to val

    var b = {} : code block, the result of the last expression will be assign to the variable

    lazy val q = 100: variable will be evaluated once will used for the first time

Strings:

    String interpolation: inject a value to string

Functions:

    function signuture: def <name>(<param>: <type>): <return type> = {code}
    function optional params: def <name>(<param>: <type> = <value>): <return type> = {code}
    Incline function:   def <name>(<param>: <type>) = <expression> or {code block}
    anonymous function: val <var name> = <name>(<param>: <type>) = <expression> or {code block}

    Higher order functions: receive as param or return a function 

        signuture: def <name>(<param1>: <dtype>.., f(<dtype>, <dtype>) => <dtype>): <dtype> = <code>
        usage    : val result = <name>(<param val>, <inline func>)
                        <inline func>: can be used _ placeholders for less code


    Partially apply functions: The idea is that i can fill some of the input params and at a later step pass the variable  and fill the rest of the params 
    Closures: closures are functions that uses variables outside of the scope of the function
              if the variable is declared as var then the closure is impure
              if the variable is declared as val then the closure is pure because for the same input return the same output
    Curring functions: the idea is to convert functions that accept multiple params to functions that accept single params
                       
                       def log(date: Date, msg: String)   ===>  def log(date: Date) = (msg: String) => println(s"$date: $msg")

                                                                val logger = log(now())
                                                                logger("This is a log")  -------> it will output "2024-01-01: This is a log"